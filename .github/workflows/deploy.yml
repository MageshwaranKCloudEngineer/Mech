name: MechWiz CI/CD Pipeline (Local K8s + Terraform + Observability + Testing)

on:
  push:
    branches:
      - dev
      - test
      - stage
      - main
  workflow_dispatch:

env:
  IMAGE_NAME: mechwiz
  VERSION_TAG: ${{ github.run_number }}

jobs:
  # 1Ô∏è‚É£ Build & Test with Pytest
  build-and-test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: 3.9

      - name: Install dependencies
        run: pip install -r requirements.txt

      - name: Run tests
        run: pytest --cov=app --cov-report=xml --junitxml=pytest-report.xml test_app.py

      - name: Upload test results
        uses: actions/upload-artifact@v4
        with:
          name: pytest-results
          path: pytest-report.xml

      - name: Upload coverage report
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report
          path: coverage.xml

  # 2Ô∏è‚É£ Deploy to environment using kind
  deploy-to-env:
    needs: build-and-test
    runs-on: ubuntu-latest
    environment:
      name: ${{ github.ref_name }}
    if: startsWith(github.ref, 'refs/heads/dev') || startsWith(github.ref, 'refs/heads/test') || startsWith(github.ref, 'refs/heads/stage') || startsWith(github.ref, 'refs/heads/main')
    steps:
      - uses: actions/checkout@v4

      # Docker setup
      - name: Set up Docker
        uses: docker/setup-buildx-action@v3

      # Install kind
      - name: Install kind
        run: |
          curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.20.0/kind-linux-amd64
          chmod +x ./kind
          sudo mv ./kind /usr/local/bin/kind

      # Create kind cluster
      - name: Create kind cluster
        run: kind create cluster --name mechwiz-cluster

      - name: Verify cluster
        run: kubectl cluster-info

      # Build Docker image inside deploy job
      - name: Build Docker image
        run: docker build -t $IMAGE_NAME:latest .

      # Load Docker image into kind
      - name: Load image into kind
        run: kind load docker-image $IMAGE_NAME:latest --name mechwiz-cluster

      # Apply Kubernetes manifests
      - name: Deploy Kubernetes manifests
        run: |
          ENV=${{ github.ref_name }}
          echo "üöÄ Deploying to $ENV"
          kubectl create namespace $ENV --dry-run=client -o yaml 

        # Apply Kubernetes manifests (all in ./k8)  
      - name: Apply Kubernetes manifests
        run: |
          kubectl get namespace $ENV >/dev/null 2>&1 || kubectl create namespace
          for file in k8/dynamodb*.yaml; do
            kubectl apply -f "$file" -n $ENV
          done

          for file in k8/*.yaml; do
            [ "$file" != "k8/dynamodb-service.yaml" ] && kubectl apply -f "$file" -n $ENV
          done

    # Verify deployments and services
      - name: Verify resources
        run: |
          kubectl get pods -n mech
          kubectl get svc -n mech
          kubectl get ingress -n mech
      # Terraform
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.0

      - name: Terraform Init & Apply
        run: |
          terraform -chdir=./terraform init
          terraform -chdir=./terraform plan -out=plan.tfplan
          terraform -chdir=./terraform apply -auto-approve
        env:
          TF_VAR_image_repo: $IMAGE_NAME
          TF_VAR_image_tag: ${{ github.run_number }}

      # Health check
      - name: Wait for pods
        run: |
          ENV=${{ github.ref_name }}
          for i in {1..12}; do
            NOT_READY=$(kubectl get pods -n $ENV --no-headers | grep -v 'Running\|Completed' || true)
            if [ -z "$NOT_READY" ]; then
              echo "‚úÖ All pods are running."
              break
            else
              echo "Waiting for pods to be ready..."
              sleep 10
            fi
          done
          if [ ! -z "$NOT_READY" ]; then
            echo "‚ùå Pods not ready, failing deployment."
            exit 1
          fi

      # Optional Grafana dashboards
      - name: Deploy Grafana dashboards
        run: |
          ENV=${{ github.ref_name }}
          if [ -f ./grafana/dashboards.json ]; then
            curl -s -X POST -H "Content-Type: application/json" \
              -d @./grafana/dashboards.json \
              http://admin:admin@grafana-service:3000/api/dashboards/db || echo "‚ö†Ô∏è Dashboard provisioning failed"

  # 3Ô∏è‚É£ Auto-promote dev ‚Üí test ‚Üí stage
  promote-envs:
    needs: deploy-to-env
    runs-on: ubuntu-latest
    steps:
      # Merge dev ‚Üí test automatically
      - name: Merge dev ‚Üí test
        if: github.ref == 'refs/heads/dev'
        run: |
          git config user.name "github-actions"
          git config user.email "actions@github.com"
          git checkout test
          git merge dev --no-ff -m "Automated merge dev ‚Üí test"
          git push origin test
      - name: Trigger deployment for test
        if: github.ref == 'refs/heads/dev'
        uses: peter-evans/repository-dispatch@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          event-type: promote-to-test
          client-payload: '{"branch": "test"}'

      # Merge test ‚Üí stage automatically
      - name: Merge test ‚Üí stage
        if: github.ref == 'refs/heads/test'
        run: |
          git config user.name "github-actions"
          git config user.email "actions@github.com"
          git checkout stage
          git merge test --no-ff -m "Automated merge test ‚Üí stage"
          git push origin stage
      - name: Trigger deployment for stage
        if: github.ref == 'refs/heads/test'
        uses: peter-evans/repository-dispatch@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          event-type: promote-to-stage
          client-payload: '{"branch": "stage"}'

  # 4Ô∏è‚É£ Manual approval before main
  approve-main:
    needs: deploy-to-env
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/stage'
    environment:
      name: main
    steps:
      - name: Await manual approval
        uses: hmarr/auto-approve-action@v2
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}

  # 5Ô∏è‚É£ Listener for promotion events
  handle-promotion:
    if: github.event_name == 'repository_dispatch'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Deploy promoted branch
        run: |
          BRANCH="${{ github.event.client_payload.branch }}"
          echo "üî• Promotion triggered for $BRANCH"
          git checkout $BRANCH
          # Call the same deploy logic here


      # üü¢ Port-forward services temporarily for integration testing
      - name: Port-forward services for testing
        run: |
          echo "Starting port-forwards..."

          kubectl port-forward svc/mechwiz-service 8081:80 -n mech &
          MECH_PID=$!

          kubectl port-forward svc/grafana-service 3000:3000 -n mech &
          GRAF_PID=$!

          kubectl port-forward svc/dynamodb-service 8000:8000 -n mech &
          DYNAMO_PID=$!

          kubectl port-forward svc/prometheus-service 9090:9090 -n mech &
          PROM_PID=$!

          # Wait a few seconds for port-forwards to be ready
          sleep 5

          echo "Port-forwards started. Running integration tests..."

          # Example: Test Mechwiz service
          curl -s http://localhost:8081/health || echo "‚ö†Ô∏è Mechwiz service not ready"

          # Example: Test DynamoDB
          curl -s http://localhost:8000/ || echo "‚ö†Ô∏è DynamoDB not ready"

          # Cleanup all port-forwards
          echo "Cleaning up port-forwards..."
          kill $MECH_PID $GRAF_PID $DYNAMO_PID $PROM_PID

