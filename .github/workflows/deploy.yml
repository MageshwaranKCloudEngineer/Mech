name: MechWiz CI/CD Pipeline (Local K8s + Terraform + Observability + Testing)

on:
  push:
    branches:
      - dev
      - test
      - stage
      - main
  workflow_dispatch:

env:
  IMAGE_NAME: mechwiz
  VERSION_TAG: ${{ github.run_number }}

jobs:
  # 1Ô∏è‚É£ Build & Test with Pytest
  build-and-test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: 3.9

      - name: Install dependencies
        run: pip install -r requirements.txt

      - name: Run tests
        run: pytest --cov=app --cov-report=xml --junitxml=pytest-report.xml test_app.py

      - name: Upload test results
        uses: actions/upload-artifact@v4
        with:
          name: pytest-results
          path: pytest-report.xml

      - name: Upload coverage report
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report
          path: coverage.xml

  # 2Ô∏è‚É£ Deploy to environment using kind
  deploy-to-env:
    needs: build-and-test
    runs-on: ubuntu-latest
    environment:
      name: ${{ github.ref_name }}
    if: startsWith(github.ref, 'refs/heads/dev') || startsWith(github.ref, 'refs/heads/test') || startsWith(github.ref, 'refs/heads/stage') || startsWith(github.ref, 'refs/heads/main')
    steps:
      - uses: actions/checkout@v4

      # Docker setup
      - name: Set up Docker
        uses: docker/setup-buildx-action@v3

      # Install kind
      - name: Install kind
        run: |
          curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.20.0/kind-linux-amd64
          chmod +x ./kind
          sudo mv ./kind /usr/local/bin/kind

      # Create kind cluster
      - name: Create kind cluster
        run: kind create cluster --name mechwiz-cluster

      - name: Verify cluster
        run: kubectl cluster-info

      # Build Docker image inside deploy job
      - name: Build Docker image
        run: docker build -t $IMAGE_NAME:latest .

      # Load Docker image into kind
      - name: Load image into kind
        run: kind load docker-image $IMAGE_NAME:latest --name mechwiz-cluster

      # Apply Kubernetes manifests
      - name: Deploy Kubernetes manifests
        run: |
          ENV=${{ github.ref_name }}
          echo "üöÄ Deploying to $ENV"
          kubectl create namespace $ENV --dry-run=client -o yaml | kubectl apply -f -
          if [ -d "./k8s" ]; then
            kubectl kustomize ./k8s | \
              sed "s|IMAGE_TAG|${{ github.run_number }}|g" | \
              sed "s|IMAGE_REPO|$IMAGE_NAME|g" | \
              kubectl apply -n $ENV -f - --validate=false
          else
            echo "‚ö†Ô∏è Directory ./k8s/$ENV not found, skipping deployment"
          fi

      # Terraform
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.0

      - name: Terraform Init & Apply
        run: |
          terraform -chdir=./terraform init
          terraform -chdir=./terraform plan -out=plan.tfplan
          terraform -chdir=./terraform apply -auto-approve
        env:
          TF_VAR_image_repo: $IMAGE_NAME
          TF_VAR_image_tag: ${{ github.run_number }}

      # Health check
      - name: Wait for pods
        run: |
          ENV=${{ github.ref_name }}
          for i in {1..12}; do
            NOT_READY=$(kubectl get pods -n $ENV --no-headers | grep -v 'Running\|Completed' || true)
            if [ -z "$NOT_READY" ]; then
              echo "‚úÖ All pods are running."
              break
            else
              echo "Waiting for pods to be ready..."
              sleep 10
            fi
          done
          if [ ! -z "$NOT_READY" ]; then
            echo "‚ùå Pods not ready, failing deployment."
            exit 1
          fi

      # Optional Grafana dashboards
      - name: Deploy Grafana dashboards
        run: |
          ENV=${{ github.ref_name }}
          if [ -f ./grafana/dashboards.json ]; then
            curl -s -X POST -H "Content-Type: application/json" \
              -d @./grafana/dashboards.json \
              http://admin:admin@grafana-service:3000/api/dashboards/db || echo "‚ö†Ô∏è Dashboard provisioning failed"

  # 3Ô∏è‚É£ Auto-promote dev ‚Üí test ‚Üí stage
  promote-envs:
    needs: deploy-to-env
    runs-on: ubuntu-latest
    steps:
      # Merge dev ‚Üí test automatically
      - name: Merge dev ‚Üí test
        if: github.ref == 'refs/heads/dev'
        run: |
          git config user.name "github-actions"
          git config user.email "actions@github.com"
          git checkout test
          git merge dev --no-ff -m "Automated merge dev ‚Üí test"
          git push origin test
      - name: Trigger deployment for test
        if: github.ref == 'refs/heads/dev'
        uses: peter-evans/repository-dispatch@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          event-type: promote-to-test
          client-payload: '{"branch": "test"}'

      # Merge test ‚Üí stage automatically
      - name: Merge test ‚Üí stage
        if: github.ref == 'refs/heads/test'
        run: |
          git config user.name "github-actions"
          git config user.email "actions@github.com"
          git checkout stage
          git merge test --no-ff -m "Automated merge test ‚Üí stage"
          git push origin stage
      - name: Trigger deployment for stage
        if: github.ref == 'refs/heads/test'
        uses: peter-evans/repository-dispatch@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          event-type: promote-to-stage
          client-payload: '{"branch": "stage"}'

  # 4Ô∏è‚É£ Manual approval before main
  approve-main:
    needs: deploy-to-env
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/stage'
    environment:
      name: main
    steps:
      - name: Await manual approval
        uses: hmarr/auto-approve-action@v2
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}

  # 5Ô∏è‚É£ Listener for promotion events
  handle-promotion:
    if: github.event_name == 'repository_dispatch'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Deploy promoted branch
        run: |
          BRANCH="${{ github.event.client_payload.branch }}"
          echo "üî• Promotion triggered for $BRANCH"
          git checkout $BRANCH
          # Call the same deploy logic here
